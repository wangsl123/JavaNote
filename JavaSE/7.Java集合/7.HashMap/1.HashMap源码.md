## jdk7
底层：数组+链表
HashMap map = new HashMap;
在实例化后，底层创建了一个长度为16的一维数组 Entry[] table

map.put(key1,value1);
首先，会调用key1的hashCode方法计算哈希值，得出key1-value1在Entry数组中的位置；
如果此位置没有数据，则添加成功；-----情况一
若有数据，则比较以存在数据的key的哈希值（相同位置的数组以链表的形式存在）：
    若果key1的哈希值与已有数据的哈希值不同，则添加成功；-----情况二
    如果key1哈希值与key2的哈希值相同，则继续调用key的equals方法：
        若返回为false，则添加成功；----情况三
        若返回true，则value2替换为value1；

在不断的添加过程中，会涉及扩容问题，扩容为原来的2倍


## jdk8
底层：数组+链表+红黑树

不同：
1. new HashMap();不创建长度为16的数组
2. 底层数组为node[]
3. 首次put时，才会创建16的数组
4. 当数组某一位置上的链表长度大于8，且数组长度大于64；
    此时此索引位置上的数据改为用红黑树存储